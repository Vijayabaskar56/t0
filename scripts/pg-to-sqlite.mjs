#!/usr/bin/env node
/**
 * Convert PostgreSQL dump to SQLite-compatible SQL
 * Handles 284MB data.sql file with streaming processing
 */

import { createReadStream, createWriteStream } from 'fs';
import { createInterface } from 'readline';
import { pipeline } from 'stream/promises';

const INPUT_FILE = './data/data.sql';
const OUTPUT_FILE = './data/data-sqlite.sql';

// Track conversion stats
const stats = {
  linesProcessed: 0,
  linesSkipped: 0,
  insertsConverted: 0,
  copyStatementsConverted: 0,
};

// Lines to skip (PostgreSQL-specific commands)
const skipPatterns = [
  /^SET /,
  /^SELECT pg_/,
  /^CREATE EXTENSION/,
  /^COMMENT ON/,
  /^ALTER TABLE .* OWNER TO/,
  /^ALTER SEQUENCE .* OWNER TO/,
  /^CREATE SEQUENCE/,
  /^ALTER SEQUENCE .* OWNED BY/,
  /^ALTER TABLE ONLY .* ALTER COLUMN .* SET DEFAULT nextval/,
  /^--$/,  // Empty comments
  /^\s*$/,  // Empty lines
];

// COPY command state
let inCopyBlock = false;
let copyTable = null;
let copyColumns = [];

/**
 * Convert a PostgreSQL line to SQLite format
 */
function convertLine(line) {
  stats.linesProcessed++;

  // Skip PostgreSQL-specific lines
  for (const pattern of skipPatterns) {
    if (pattern.test(line)) {
      stats.linesSkipped++;
      return null;
    }
  }

  // Handle COPY statements (PostgreSQL bulk insert format)
  const copyMatch = line.match(/^COPY public\.(\w+) \((.*?)\) FROM stdin;$/);
  if (copyMatch) {
    inCopyBlock = true;
    copyTable = copyMatch[1];
    copyColumns = copyMatch[2].split(', ');
    stats.copyStatementsConverted++;
    return `-- COPY ${copyTable} converted to INSERT statements below`;
  }

  // End of COPY block
  if (line === '\\.') {
    inCopyBlock = false;
    copyTable = null;
    copyColumns = [];
    return null;
  }

  // Convert COPY data to INSERT
  if (inCopyBlock) {
    const values = line.split('\t').map(val => {
      if (val === '\\N') return 'NULL';  // PostgreSQL NULL representation

      // Escape single quotes
      val = val.replace(/'/g, "''");

      // Convert PostgreSQL escapes
      val = val.replace(/\\n/g, '\n');
      val = val.replace(/\\r/g, '\r');
      val = val.replace(/\\t/g, '\t');
      val = val.replace(/\\\\/g, '\\');

      return `'${val}'`;
    });

    stats.insertsConverted++;
    return `INSERT INTO ${copyTable} (${copyColumns.join(', ')}) VALUES (${values.join(', ')});`;
  }

  // Convert CREATE TABLE statements (remove public schema, adjust types)
  if (line.startsWith('CREATE TABLE public.')) {
    return line.replace('CREATE TABLE public.', 'CREATE TABLE ');
  }

  // Convert ALTER TABLE ONLY for PRIMARY KEY
  if (line.includes('ALTER TABLE ONLY public.')) {
    return line.replace('ALTER TABLE ONLY public.', 'ALTER TABLE ');
  }

  // Convert ADD CONSTRAINT for PRIMARY KEY and FOREIGN KEY
  if (line.includes('ADD CONSTRAINT') && (line.includes('PRIMARY KEY') || line.includes('FOREIGN KEY'))) {
    return line.replace(/public\./g, '');
  }

  // Convert CREATE INDEX
  if (line.startsWith('CREATE INDEX') || line.startsWith('CREATE UNIQUE INDEX')) {
    return line.replace(/public\./g, '').replace(/ USING \w+/g, '');
  }

  // Convert INSERT statements
  if (line.startsWith('INSERT INTO public.')) {
    stats.insertsConverted++;
    return line.replace('INSERT INTO public.', 'INSERT INTO ');
  }

  // Convert column types in CREATE TABLE
  if (line.includes('character varying')) {
    line = line.replace(/character varying\(\d+\)/g, 'TEXT');
  }
  if (line.includes('timestamp without time zone')) {
    line = line.replace(/timestamp without time zone/g, 'TEXT');
  }
  if (line.includes('numeric')) {
    line = line.replace(/numeric/g, 'TEXT');
  }

  // Skip ALTER TABLE for defaults (already in CREATE TABLE)
  if (line.includes('ALTER TABLE') && line.includes('SET DEFAULT')) {
    stats.linesSkipped++;
    return null;
  }

  // Keep comments and other statements
  return line;
}

/**
 * Main conversion function
 */
async function convert() {
  console.log('ğŸ”„ Starting PostgreSQL to SQLite conversion...');
  console.log(`ğŸ“– Input: ${INPUT_FILE}`);
  console.log(`ğŸ“ Output: ${OUTPUT_FILE}`);
  console.log('');

  const input = createReadStream(INPUT_FILE, { encoding: 'utf8' });
  const output = createWriteStream(OUTPUT_FILE, { encoding: 'utf8' });
  const rl = createInterface({ input });

  // Write SQLite header
  output.write('-- SQLite conversion of PostgreSQL dump\n');
  output.write('-- Generated by pg-to-sqlite.mjs\n');
  output.write('PRAGMA foreign_keys = OFF;\n');
  output.write('BEGIN TRANSACTION;\n\n');

  let lastProgress = 0;
  for await (const line of rl) {
    const converted = convertLine(line);
    if (converted !== null) {
      output.write(converted + '\n');
    }

    // Progress indicator every 100k lines
    if (stats.linesProcessed % 100000 === 0) {
      const progress = Math.floor(stats.linesProcessed / 10000) / 100;
      if (progress !== lastProgress) {
        console.log(`â³ Processed ${(stats.linesProcessed / 1000).toFixed(0)}k lines...`);
        lastProgress = progress;
      }
    }
  }

  // Write SQLite footer
  output.write('\nCOMMIT;\n');
  output.write('PRAGMA foreign_keys = ON;\n');
  output.end();

  // Wait for write to finish
  await new Promise(resolve => output.on('finish', resolve));

  console.log('');
  console.log('âœ… Conversion complete!');
  console.log('');
  console.log('ğŸ“Š Statistics:');
  console.log(`  Lines processed: ${stats.linesProcessed.toLocaleString()}`);
  console.log(`  Lines skipped: ${stats.linesSkipped.toLocaleString()}`);
  console.log(`  INSERT statements: ${stats.insertsConverted.toLocaleString()}`);
  console.log(`  COPY blocks converted: ${stats.copyStatementsConverted}`);
  console.log('');
  console.log(`ğŸ“ Output file: ${OUTPUT_FILE}`);
}

// Run conversion
convert().catch(err => {
  console.error('âŒ Conversion failed:', err);
  process.exit(1);
});
